
---
## Ресурсы:
1. Данные конспекты выкладывались ранее [тут](https://vk.com/lambda_brain_not_null) (сейчас данные материалы уже не доступны)
2. Оригинал заметки лежит в этом репозитории по адресу `resource/lambda-brain-not-null/lambda-brain-not-null-23-the-power-of-low-level.zip

---

Я постоянно призываю думать над проектом как можно более сильными абстракциями, и может показаться, что для этого надо использовать только небольшое число функциональных языков со строгой системой типов. Но нет, мне на самом деле очень нравится язык Си. Я очень много на нём программировал, и по большому счёту, есть настоящая магия в том, когда "список байтов" становится фундаментальным типом данных. При использовании языков более высокого уровня в ряде ситуаций трудно понять, что на самом деле происходит во время выполнения (а это важно), но **Си идеологически близок к ассемблеру, а ассемблер никогда не врёт**. Ассемблер -- это истина в конечной инстанции.

Сейчас модно говорить, что дескать Си -- это совсем устаревший язык из прошлого, который всё ещё используется только потому, что пока разработчики недостаточно изучили Rust или Go. Но есть ли какие-то реальные преимущества у Си, кроме высокой производительности и приближённости к машинному коду?

Хорошая статья кембриджского учёного на эту тему: ["Some Were Meant for C"](https://www.humprog.org/~stephen//research/papers/kell17some-preprint.pdf).

Вот её краткий смысл: Язык Си ведёт двойную жизнь -- как язык прикладного программирования прошлых лет, увековеченный обстоятельствами, и как язык системного программирования, который остаётся хорошим выбором и спустя десятилетия после его создания.

Это эссе ставит под сомнение такие распространённые негативные убеждения относительно Си, как небезопасность, неопределённое поведение и чрезмерный акцент на производительности. Не то чтобы этих недостатков у Си не было; речь скорее о том, все эти свойства на самом деле несущественны; главная суперспособность языка Си заключается в его **коммуникативном дизайне (communicative design)**, который действительно нелегко вписывается в классические рамки массового представления о "языка программирования", и может рассматриваться как противопоставление так называемым "управляемым языкам". Но именно эта коммуникативность облегчает важнейший аспект разработки сложных систем: **создание частей, которые взаимодействуют друг с другом "удалённо" -- "рядом", а не "внутри" (слабая связанность модулей).**

Что именно Stephen Kell подразумевает под коммуникативностью? Речь о том, что **Си может получить доступ к структурам данных, которые были созданы другими системами, фактически без лишних усилий**. Хотите ли вы получить доступ к структурам данных ядра Linux или возиться с байтами, представляющими исполнимый код других программ, Си сделает это легко.

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>

static int __init my_module_init(void)
{
    struct task_struct *task;
    for_each_process(task)
    {
        printk(KERN_INFO "Process: %s (PID: %d)\n", task->comm, task->pid);
    }
    return 0;
}

static void __exit my_module_exit(void)
{
    printk(KERN_INFO "Module unloaded\n");
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
```

Или представьте, что вы разбираете сетевой пакет, содержащий некоторые структуры данных в соответствии со стандартом. Си может просто сказать: "Я знаю, что это такое", наложить на пакет просто как на последовательность байтов свою собственную структуру, и прочитать его как есть. В языках же вроде Java придется отдельно "вручную" десериализовать пакет в свою собственную структуру данных.

```cpp
#include <stdio.h>
#include <stdint.h>

#pragma pack(push, 1)
struct EthernetHeader
{
    uint8_t dest_mac[6];
    uint8_t src_mac[6];
    uint16_t ether_type;
};
#pragma pack(pop)

int main()
{
    uint8_t packet[] = {
	    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, // dest_mac
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, // src_mac
		0x08, 0x00
	}; // ether_type (IPv4)

    struct EthernetHeader *eth_header = (struct EthernetHeader *)packet;

    printf("Destination MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
           eth_header->dest_mac[0], eth_header->dest_mac[1],
           eth_header->dest_mac[2], eth_header->dest_mac[3],
           eth_header->dest_mac[4], eth_header->dest_mac[5]
    );

    printf("Source MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
           eth_header->src_mac[0], eth_header->src_mac[1],
           eth_header->src_mac[2], eth_header->src_mac[3],
           eth_header->src_mac[4], eth_header->src_mac[5]
    );

    printf("EtherType: 0x%04X\n", ntohs(eth_header->ether_type));

    return 0;
}
```

Некоторые разработчики говорили, что этот материал ["Some Were Meant for C"](https://www.humprog.org/~stephen//research/papers/kell17some-preprint.pdf) изменил их вычислительное мировоззрение :) Может быть, это случится и с вами?

И хотя Си называют низкоуровневым, в нём правильно (и положено по стандартам!) думать не в императивных строках кода, а в абстракциях - **sequence points** (а если хотите абстрактные типы данных, применяйте union :).  
Вы видели в стандартах любого популярного современного языка наподобие Java хоть что-то подобное?  
Я подробно разбирал этот момент в материале [Про Си и Rust в 2024-м](https://vk.com/wall-152484379_3638).

Здесь есть и более общий урок: **сила расшаренного формата**. Не только возможность читать и писать данные в одном и том же формате, но и прозрачное его использование во внутренних вычислениях. 40 лет философия Unix демонстрирует, какую мощь вы можете получить, если у вас будут пайпы программ, которые общаются с помощью обычного текста. Это невероятно контрастирует с конкурирующей философией проприетарных форматов файлов вообще для всего, так что всё взаимодействие с ними должно проходить через промежуточные конвертеры.

Таким образом, урок языка Си -- это великолепный урок, который мы можем повторить и в повседневной практике и жизни: **чтобы общаться с другими, мы должны научиться говорить на общем языке, а не постоянно переводить тексты туда-сюда**.

И всегда, когда вы думаете, что какая-то технология добилась успеха наперекор своей, как нам кажется, технической неполноценности, подумайте ещё раз.

