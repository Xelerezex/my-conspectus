
---

В отличии от обычных базовых алгоритмов, у которых строго определены задачи, которые они решают, дано формальное описание и подробно описано как эти алгоритмы работают, метод двух указателей - это прием, имеющий много вариаций и не имеющего строго формального описания.

При этом - владеть этим приемом очень важно, так как его любят давать на собесах, ну и плюс он улучщает навык написания аккуратного кода (особенно с ошибками на +1, -1 - любимые ошибки всех на алгоритмах).

Поэтому данный метод будем разбирать на примерах и задачах, которые можно найти в этой папке.

Метод двух указателей не имеет формального описания, но при этом это очень полезный набор приемов, который позволяет снизить порядок асимптотик, к примеру перейти от $O(N^2)$ к $O(N)$

---
## Общее описание
- Данное описание взято вот с [этого видео](https://www.youtube.com/watch?v=MyWNZJ10zIU). Первый две минуты автор очень хорошо описывает этот метод.

1. Существует некоторый массив данных от $0$ до $n-1$:
   ![[algo-foundation-two-pointers-27.svg]]
2. Есть признак, по которому некоторые его подотрезки считаются хорошими, а некоторые плохими: 
	![[algo-foundation-two-pointers-28 1.svg]]
3. Причем есть свойство, если отрезок $\textcolor{#D6B656}{хороший}$ - то и любой его подотрезок тоже $\textcolor{#D6B656}{хороший}$. А если отрезок $\textcolor{#B85450}{плохой}$, то и его отрезок $\textcolor{#B85450}{плохой}$: 
   ![[algo-foundation-two-pointers-29.svg]]
Теперь  мы хотим найти к примеру: $\textcolor{#D6B656}{Хороший}$ отрезок максимальной длины? Или, еще валидный вариант - посчитать количество $\textcolor{#D6B656}{хороших}$ отрезков.

 Тогда мы заведем следующий отрезок:
 ![[algo-foundation-two-pointers-30.svg]]
 Со свойством, что от $\textcolor{#D6B656}{l}$ до $\textcolor{#D6B656}{r}$ отрезок считается $\textcolor{#D6B656}{хорошим}$
 Но при этом от $\textcolor{#B85450}{l-1}$ до $\textcolor{#D6B656}{r}$ - это уже $\textcolor{#B85450}{плохой}$ отрезок:
![[algo-foundation-two-pointers-31.svg]]
Давайте тогда расширим отрезок на один вправо:
![[algo-foundation-two-pointers-32.svg]]
Тогда у нас получится два возможных кейса:
1. Если отрезок от  $\textcolor{#D6B656}{l}$ до $\textcolor{#D6B656}{r + 1}$ - $\textcolor{#D6B656}{хороший}$:
   ![[algo-foundation-two-pointers-33.svg]]
   Тогда свойство **соблюдается**, потому что отрезок от $\textcolor{#B85450}{l-1}$ до $\textcolor{#D6B656}{r + 1}$ точно будет $\textcolor{#B85450}{плохой}$:
   ![[algo-foundation-two-pointers-34.svg]]
   2. Если отрезок от $\textcolor{#D6B656}{l}$ до  $\textcolor{#B85450}{r+1}$ - $\textcolor{#B85450}{плохой}$: ![[algo-foundation-two-pointers-35 1.svg]]
   То мы сдвинем $\textcolor{#D6B656}{l'}$ до тех пор пока отрезок не станет хорошим:![[algo-foundation-two-pointers-36.svg]]
   Вот пускай первое место теперь это  $\textcolor{#D6B656}{l'}$, тогда мы получаем, что отрезок от  $\textcolor{#D6B656}{l'}$ до  $\textcolor{#D6B656}{r+1}$ -  $\textcolor{#D6B656}{хороший}$.  А от $\textcolor{#B85450}{l'-1}$ - $\textcolor{#B85450}{плохой}$. И значит свойство тоже соблюдается.
### Как запрограммировать:

Некоторые пишут это так:

```cpp
while ...
	if ...
		++r;
	else
		++l;
```

Но так не очень хорошо писать, так как в самом цикле меняется сразу две переменных и это не очень интуитивно понятно. Мне больше нравится так:

```cpp
for r = 0 ... n-1
	while [l..r] - плохой
		++l;
```

В таком случае, на каждой итерации цикла `for` мы переходим от отрезка  $[\textcolor{#B85450}{l'-1}\ \dots\ \textcolor{#D6B656}{r}]$  к $[\textcolor{#D6B656}{l'}\ \dots\ \textcolor{#D6B656}{r + 1}]$ 

---
## Заметки

- Когда начинаешь писать алгоритм - лучше всего что бы в основном цикле ты бежал по `first` указателю.
- Самый удобный вариант двух указателей это цикл `for()` в который вложен `while()`
  То есть: `for() { while() { } }`
- Так же всегда стоит помнить про монотонность, елси она присутствует в задаче - то проще гнать двумя указательями по таким данным. Так как например для одного элемента выполянется свойство, а для следующего уже нет. Это значит что достаточно сделать `+1`.
- В приницпе метод двух указателей помогает сократить асимптотику алгоритма (в случае где два массива) с $O(N*M)$ до $O(N+M)$.
- Когда что-то пишешь в `while(data[second] < value) { ++second; }` для второго указателя - всегда стоит вставлять проверку на переполнение, типа: 
  `while(second < data.size() && second < value) { ++second; }`. Потому ни один из указателей не должен привышать индекса последнего элемента данных.
- **Не более** == **Меньше или равно**. **Не менее** == **Больше или равно**.  
- 