
---
- [Ссылка на оригинал урока](https://neetcode.io/courses/dsa-for-beginners/27).
---
В любой реализации хэш-мапы или хэш-сета, впервую очеред, будет находиться таблица хэширования. Но что это такое? Обычно это просто массив, который хранит в себе указатели на списки с данными. Что бы обратится к этому массиву за $O(1)$ нужно просто взять значение по индексу. И если к нас ключи это строки. То хэш-функция превращает __строку в индекс для массива__.
К примеру, если у нас есть ключ `"Tormund"` то мы можем взять каждую букву, перегнать ее в `ASCII` $84 + 111 + 114 + 109 +117 + 110 + 100 = 745$. А теперь предположим что наша хэш-таблица проаллоцирована на 10 элементов, а значит нам надо разделить по модулю $10$ получившееся выше число $745\ \%\ 10 = 5$.  И значит по индексу $5$ мы можем разместить наше значение, соотвествующее ключу `"Tormund"`.
Ну и соотвественно, если у нас есть ключ `"Parrotq"`, который тоже дает в сумме $80 + 97 + 114 + 114 + 111 + 116 + 113 = 745$ то индекс для хэш-таблицы тоже будет  $745\ \%\ 10 = 5$.  Такая ситуация всегда была узким местом хэш-таблиц, и называется она __Коллизия__.
Как бороться с коллизиями? Ну мы можем их обходить, и минимизировать - но решить полностью эту проблему не выйдет.
Один из вариантов борьбы с коллизиями - это ресайзить хэш-таблицу, всякий раз, когда достигается некий пик. Но тут тоже есть свои подводные потому что если мы делаем действи $\% size$ и размер меняется, то меняются и индексы выдаваемые хэш-функцией. А значит нам надо пересчитать выхлоп хэш-функции для всех уже лежащих элементов, и переместить их по правильным индексам относительно нового размера хэш-таблицы (Этот процесс называется __рехэширование (rehashing)__). И да, рехэширование - это тяжелая операция в зависимости от размера.
Что бы немного сгладить вставку и не рехэшировать каждый раз - часто применяется техника __Сцеления (Chaining)__. Это когда в хэш-таблице начнинает лежать не значение, а указательна на односторонний связный список. И к примеру произошла коллизия, и тогда значение просто кладется в этот список, а если пограничное значение 3, и третий элемент должен попасть в тот же список - то только тогда идет рехэширование.
Так же существует такая техника, как __Открытая Адресация (Open Addressing)__. Смысл тут в том, что высчитывать индекс, например 1, он занят. Тогда мы пробуем положить в памяти по индексу 2. Тут свободно - кладем. Функция `get()` тогда отработает также, найдет индекс 1, поймет, что ключ не совпадает, и пойдет искать в следующем индексе и так далее. Худший случай тут тоже $O(N)$. 

## Hash Implementation в С++

Для того, что бы положить кастомный тип в `std::unordered_map` надо реализовать для кастомного типа оператор равенства и хэш-функцию:

```cpp
class Widget
{
public:
	virtual bool IsEqualTo(const Widget* b) const;
	virtual int getHashValue() const;
};

struct my_hash
{
	std::size_t operator()(const Widget* w) const
	{
		return w->getHashValue();
	}
}

struct my_equal
{
	std::size_t operator()(const Widget* a, const Widget* b) const
	{
		return a->IsEqualTo(b);
	}
}

std::unordered_map<Widget*, my_hash, my_equal> s;
```

