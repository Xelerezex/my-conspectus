
---
- [Ссылка на оригинал урока](https://neetcode.io/courses/advanced-algorithms/4).
- [[TODO. NeetCode]]: Добавить теорию с картинками
---

Чаще всего эта задача встречается в темах типа массивов.
Слово "Префикс", в данном алгоритме можно воспринимать как "Мы начинаем в начале". То есть все под-массивы считаются префиксными, если они __начинаются с начала__ и __являются непрерывными__:

![[prefix-subarrays.svg]]

Как мы видим на картинке выше, у массива в 5 элементов, существует 5 префиксных под-массивов.
Префиксные же суммы, это буквально сумма внутри определенного под-массива. Причем обратим внимание на то, что эти суммы можно брать из прошлых полученных сумм:

![[prefix-sums-of-subarrays.svg]]

Так же можно без проблем и высчитать не только сумму, но и произведение.

---
Так же существует такая вещь, как постфикс. Свойства там все те же, только начинается непрервный под-массив с конца:

![[postfix-subarrays.svg]]

Постфиксная сумма будет выглядеть так:

![[postfix-sums-of-subarrays.svg]]

---

В целом этот алгоритм как раз-таки из-за свойства переиспользования уже полученных данных хорош что бы убрать лишние действия. Условно бегать не каждый раз с начала массива, а запоминать суммы - это снизит сложность такого алгоритма с $O(N)$ до $O(1)$.
Что мы имеем в виду, под лишними действиями? У нас есть массив с уже посчитанными префиксными суммами:

![[array-with-prefix-sums.svg]]

И мы хотим найти сумму подмассива:

![[array-with-prefix-sums-1.svg]]
Для этого нам просто надо из взять сумму, которая находится по индексу $\textcolor{#FF3333}{R}$ и вычесть из нее сумму под индексом $\textcolor{#FF3333}{L-1}$, то есть сумма этого подотрезка: $\textcolor{#777777}{5 - 4; \Sigma = 1}$. 

---
## Заметки на полях

Надо быть очень аккуратным с $\textcolor{#FF3333}{L-1}$, так как при $\textcolor{#FF3333}{L = 0}$, индекс примет вид $\textcolor{#FF3333}{-1}$ и если мы по нему попробуем обратится в массив - будет ошибка рантайма.
И так же может случится переполнение типа данных если при итерации в цикле `for` выбрать тип `std::size_t`:

```cpp
for (std::size_t index = 0; index < nums.size(); ++index)
{
	const auto currentValue = (index - 1 < 0) ? 0 : m_nums[index - 1];
	m_nums.push_back(currentValue + nums[index]);
}
```

Вот тут `std::size_t index = 0;` __будет переполнение__ из-за `index - 1`. 
