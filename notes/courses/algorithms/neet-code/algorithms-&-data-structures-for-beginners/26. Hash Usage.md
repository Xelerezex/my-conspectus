
---
- [Ссылка на оригинал урока](https://neetcode.io/courses/dsa-for-beginners/26).
---

Начнем с простого обзора - чем хэш-мапы, лучше чем древовидные-мапы:

| Древидная-мап | Хэш-мап    | Операции |
| ------------- | ---------- | -------- |
| $O(log\ N)$   | $O(1)^{*}$ | Вставка  |
| $O(log\ N)$   | $O(1)^{*}$ | Удаление |
| $O(log\ N)$   | $O(1)^{*}$ | Поиск    |
$*$ В зависимости от реализации хэша. Время может и увеличится до $O(N)$ при неудачном хэшировании.

Так же один из самых больших минусов хэш-мапы, она никогда не будет отсортирована в каком-то порядке. Все хэш-мапы лежат в памяти довольно хаотично. Древовидная же мапа всегда поддерживает порядок для всех операций.

Самая любимая всеми задача для хэш-мапы и самый простой кейс её использования:
У нас даны имена: $''alice''$ , $''brad''$ , $''collin''$, $''brad''$, $''dylan''$, $''kim''$ и надо посчитать количество вхождений имен.
Для этого применим хэш-мапу и представим её в виде таблицы

| Ключ         | Значение |
| ------------ | -------- |
| $''alice''$  | 1        |
| $''brad''$   | 2        |
| $''collin''$ | 1        |
| $''dylan''$  | 1        |
| $''kim''$    | 1        |
Соотвественно, из названия идет основное свойство - в этой мапе нет никогда дубликатов. Если мы обращаемся по хэшу, который уже лежит в мапе - можем либо прочитать значение, либо его заменить, но положить рядом еще один такой же хэш - не выйдет.

Так же конкретно подсказка по решению проблем. Если в задаче есть такие слова как "Уникальный", "Посчитайте количество", "Частота" - то тут с высочайщей вероятностью надо использовать хэш-мапу.

---
## Hash Usage в С++

Под понятие хеша попадает два класса `std::unordered_set<K>` и `std::unordered_map<K, V>`. Оба этих класса представляют собой хэщ-таблицу с цепочками, то есть массив, состоящий из элементов "корзин", каждый из которых хранит односвязный список элементов данных. По мере добавляения новых элементов данных - каждый из них помещается в односвязный список с "хэшем", соответсвующим значению элемента.
Из-за того, что `std::unordered_set<K>` убирает несколько укателей в своей реализации, он показывает более высокую производительность чем древовидный `std::set<K>`.

> При этом что бы отказаться отоставшихся указателей, можно заменить связные списки в реализации на прием называющийся "Открытая Адресация". Стоит как минимум ознакомиться с этой темой. И реализовывать её если производительность `std::unordered_set<K>` покажется недостаточной.

Объявление `std::unordered_set<K>`:

```cpp
std::unordered_set<char> s { 42, 43, 44 };
```

Вот как `std::unordered_set<K>` будет выглядеть в памяти:

![[std-unordered-set.svg]]
`std::unordered_set<K>` как упрощенная замена `std::set<K>`, поэтому в нем можно использовать только прямые итераторы. Ну и собственно мы видим, что в корзинах образуются однанаправленные списки, а не двунаправленные, как в `std::set<K>`. Поэтому итерация в обратном направлении не возможна.
Так же тут можем наблюдать, что никакой порядок не соблюдается. Скорее всего при каждом запуске рантайма программы - у конкретного `std::unordered_set<K>` будет разное размещение данных.
Собственно то, что называется "Корзины" в терминах C++ - и есть __хэш-таблица__. Эта хэш таблица присутствует и в `std::unordered_set<K>` и в `std::unordered_map<K, V>`. Единственнре различие между этими классами состоит в том, что `std::unordered_map<K, V>` хранит вместо просто ключа пару ключ-значение.

Вот так вот мы задаем  `std::unordered_map<K, V>`:

```cpp
std::unordered_map<char, int>{
	{ 42, 3 },
	{ 43, 1 },
	{ 44, 4 }
};
```

И вот так он выглядит в памяти:

![[std-unordered-map.svg]]

### Фактор загрузки и списки в корзинах

Реализации хэшей в C++ открывают доступ ко всей административной информации о хэш-таблице ( хэш-таблица ака массив корзин ).
- `s.bucket_count()` - возвращает текущее количество корзин в массиве.
- `s.bucket(key)` - возвращает индекс `i` корзины, где находится элемент `key`, при условии, что он был положен в контейнер.
- `s.bucket_size(i)` - возвращает количество элементов в `i`-й корзине. Важно заметить, что всегда соблюдается условие `s.count(key) <= s.bucket_size(s.bucket(key))'.
-  `s.load_factor()` - возвращает `s.size() / s.bucket_count()` в виде числа типа `float`.  Этот механизм используется в хэш-контейнерах для масштабирования с ростом количества элементов. Так как каждый объект `s` имеет значение `s.max_load_factor()`, указывающее, насколько большим может быть `s.load_factor()`. Если вставка нового элемента привет к увеличению `s.load_factor()` выше `s.max_load_factor()`, тогда `s` перераспределит свой массив корзин и повторно выполнит хэширование элементов, что бы уменьшить `s.load_factor()` ниже уровня `s.max_load_factor()`.
- `s.rehash(count)` - Увеличивает (или уменьшает) размер массива корзин до заданной величины `n`.