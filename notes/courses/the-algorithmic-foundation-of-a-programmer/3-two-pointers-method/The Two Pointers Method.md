
---

В отличии от обычных базовых алгоритмов, у которых строго определены задачи, которые они решают, дано формальное описание и подробно описано как эти алгоритмы работают, метод двух указателей - это прием, имеющий много вариаций и не имеющего строго формального описания.

При этом - владеть этим приемом очень важно, так как его любят давать на собесах, ну и плюс он улучщает навык написания аккуратного кода (особенно с ошибками на +1, -1 - любимые ошибки всех на алгоритмах).

Поэтому данный метод будем разбирать на примерах:

---
## Задача №1

- Дан массив целых **положительных** чисел.
- Найти в нем отрезок, сумма элементов которого равна **X**.\
- Пример
	- `A = {3, 1, 5, 6, 2, 8, 7}`
	- `X = 13`
Идея нахождения отрезков:
1.  Проверяем сумму с таргетным значением
	![[algo-foundation-two-pointers-1.png]]
2. Из-за того, что сумма меньше искомой - сдвигаем правую границу
	![[algo-foundation-two-pointers-2.png]]
3.  Так как сумма стала больше, чем таргетное значение - сдвигаем левую границу:
	![[algo-foundation-two-pointers-3.png]]
	 Ну вот так мы и нашли отрезок
То есть ключевая идея решения этой задачи такая:
- Пока сумма текущего отрезка меньше таргетной - сдвигаем его правую границу, когда сумма текущего отрезка стала больше искомой, сдвигаем левую границу на один вправо.

Вот пример кода на С++ (стоит понимать, что тут надо вывести индексы, которые нумеруются с единицы):

```cpp

struct Segment
{
    int left = 0;   // Эти значения left и right в моей реализации считаются
    int right = -1; // за "не найдено"
};

Segment TheTwoPointersMethod(
    const std::vector<int>& data,
    int targetValue
)
{
    Segment segment;
    
    int right = 0;
    int sum = 0;
    for (int left = 0; left < data.size(); ++left)
    {
        while (right < data.size() && sum < targetValue)
        {
            sum += data[right];
            ++right;
        }
        if (sum == targetValue)
        {
            ++left;
            segment.left  = left;
            segment.right = right;
            break;
        }
        sum -= data[left];
    }
    
    return segment;
}

```

### Доказательство Корректности

Надо доказать два тезиса:
- Если искомого отрезка нет, наш алгоритм вернет пустой отрезок
- По построению наш алгоритм поддерживает в переменной `sum` сумму на отрезке
	
1. Если искомого отрезка нет, наш алгоритм вернет пустой отрезок
	По построению наш алгоритм поддерживает в переменной `sum` сумму на отрезке нашего массива. Таким образом, если искомого отрезка нет, то и наш алгоритм его не найдет, он вернет пустой отрезок, потому что он принимает решение, что отрезок найден на основании суммы на каком-то отрезке. Поэтому если нет такой ссумы, которую мы ищем - то наш алгоритм ее и не найдет
2. Докажем, что наш алгоритм находит отрезое с заданной суммой когда он есть.
	Для этого пойдем от обратного и предположим, что это не так. Наш алгоритм не нашел отрезок, хотя он был.
	Рассмотрим следующую ситуацию, пусть желтым обозначен отрезок, который мы ищем:
	![[algo-foundation-two-pointers-4.png]]
	Так как мы доказываем от противного, то что бы отрезок не был найден, когда `l` стал указывать на левую границу отрезка:
	![[algo-foundation-two-pointers-5.png]]
	То тогда указатель `r` должен быть правее, чем правая граница отрезка:
	![[algo-foundation-two-pointers-6.png]]
	При этом мы сдвигаем указатель `l` в тот момент, когда текущая накопленная сумма оказалась больше таргетной:
	![[algo-foundation-two-pointers-7.png]]
	Но в такой ситуации `r` не может находиться правее нужного отрезка:
	![[algo-foundation-two-pointers-8.png]]
	Ну и в любом случае теперь `r` не будет никуда сдвигаться, тк сумма не может быть больше таргетной. А значит в итоге мы получим:
	![[algo-foundation-two-pointers-9.png]]
	 
---
