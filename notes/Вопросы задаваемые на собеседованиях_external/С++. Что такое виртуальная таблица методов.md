## Или в двух словах о слове virtual.

---

### Ресурсы:

1. [Как виртуальные функции работают под капотом?](https://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/) Часть I.
2. [Как виртуальные функции работают под капотом?](https://www.vishalchovatiya.com/part-2-all-about-virtual-keyword-in-cpp-how-virtual-class-works-internally/) Часть II.
3. [Как виртуальные функции работают под капотом?](https://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/) Часть III.
4. [Проблема вызова виртуальной функции из конструктора/деструктора](https://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors).

---

![[memory-layout-of-C-objects.png]]

---

### Дисклеймер:

В реальных проектах стоит помнить, что:

- Реализация динамической диспетчеризация очень компиляторо-зависимая.
- Стандарт `С++` не определяет реализацию динамической диспетчеризации - он только указывает её поведение.

---

## Цель данного конспекта:

Ответить на вопрос: Как виртуальные функции работает под капотом?

Или другими словами: Как в `С++` реализована динамическая диспетчеризация?

---

## Краткий обзор содержания:

1. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
2. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
    1. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
3. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
4. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
5. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
    1. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
    2. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
6. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
7. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
8. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
9. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]
10. [[notes/Вопросы задаваемые на собеседованиях_external/С++. Что такое виртуальная таблица методов|С++. Что такое виртуальная таблица методов]]

---

## 1. Для чего нам нужны виртуальные функции?

Начнем сразу с примера.

У нас есть телефон, с которого мы хотим либо выйти в интернет, либо подключиться к другому телефону. Сделать это можно при помощи Wifi или Bluetooth. Хоть это и совершенно разные технологии, они будут обладать общими свойствами, к примеру, подключение по выбранному протоколу, или аутентификация.

В коде, нужные классы, мы это представим так:

```C++
class wifi_t
{
    private:
        char _pass[15];
    public:
        void authenticate();
        void connect();
};

class bluetooth_t
{
    private:
        char _pass[15];
    public:
        void authenticate();
        void connect();
};
```

После написания классов примерная логика программы будет написана следующим образом:

```C++
int main()
{
    wifi_t      *wifi = new wifi_t;
    bluetooth_t *bluetooth = new bluetooth_t;

    int prtcl = selectProtocol();

    if (prtcl == BLUETOOTH)
		{
        bluetooth->authenticate();
        bluetooth->connect();
    }
    else if(prtcl == WIFI)
		{
        wifi->authenticate();
        wifi->connect();
    }

    return 0;
}
```

Мы внимательно посмотрели на код, который написали выше, и решили, что от дублирования кода в программе лучше избавиться. Поэтому перепишем наши классы, отнаследовав их от общего интерфейса и определив виртуальные функции `connect` и `authenticate`:

```C++
class protocol_t
{
    private:
        uint8_t _type;
    
    public:
        virtual void authenticate() {};
        virtual void connect() {};
};

class wifi_t : public protocol_t
{
    private:
        char _pass[15];
    public:
        void authenticate() override {};
        void connect()      override {};
};

class bluetooth_t : public protocol_t
{
    private:
        char _pass[15];
    public:
        void authenticate() override {};
        void connect()      override {};
};
```

Поэтому из основной программы можно будет выкинуть дублирования кода:

```C++
void makeConnection(protocol_t *protocol)
{
    protocol->authenticate();
    protocol->connect();
} 

int main()
{
    int prtcl = selectProtocol();

    if (prtcl == WIFI)
    {
        makeConnection(new wifi_t);
    }
    else
    {
        makeConnection(new bluetooth_t);
    }

    return 0;
}
```

Это в примере лишь два метода `connect` и `authenticate` а если бы их было больше? А если бы и ветвление у нас было с большим количеством вариантов? Мы просто захламили весь наш код вызовами функций с одинаковыми сигнатурами.

Использовав наследование и ключевое слово `virtual` мы добились:

- **Полиморфизма во время исполнения программы**: такие поведенческие функции идентифицируются, когда к ним обращаются в рантайме программы. То есть именно во время работы программы когда произойдет обращение к `protocol->connect();` обратится либо к `wifi_t`, либо к `bluetooth_t` в зависимости от контекста.
- **Переиспользование кода**: мы вызываем только один раз `makeConnection` , а не 2 раза по две различные функции (как было сказано выше, представим ситуацию, когда методов и ветвлений больше чем два). Это добавило коду компактности

---

## 2. Как виртуальные функции работают под капотом?

- При объявлении какой-то функции виртуальной компилятор подменит (прирастит, тоже хорошее слово тут) код этой функции во время исполнения программы.
- В нашем случаем, сам базовый класс интерфейса `protocol_t` будет расширен компилятором на один дополнительный указатель - `_vptr` . Это указатель на виртуальную таблицу.
- Другими словами: виртуальная функция ни что иное, как указатель на массив указателей на функции.

Значит, что компилятор вызов метода `authenticate()` класса `protocol_t` :

```C++
protocol_t *protocol;

protocol->authenticate();
```

Раскроет в что-то подобное:

```C++
(*protocol->_vptr[ 1 ])( protocol );
```

- Небольшое пояснение
    1. `_vptr` - это внутренне генерируемый компилятором указатель на виртуальную таблицу. Данный указатель появляется в классе, если класс наследуется от сущности с объявленной виртуальной функцией, или если он сам объявляет виртуальную функцию. В сложных классах может быть несколько таких указателей.
    2. `1` - это индекс в `_vptr[ 1 ]` которое сопоставляется с функцией `authenticate()` в массиве виртуальных функций. Индекс выбирается компилятором и он зафиксирован в дереве наследования за данным методом.
    3. `( protocol )` - это будет указатель на `this` .

Когда мы наследуемся классом `wifi_t` от класса `protocol_t` - будет создана новая виртуальная таблица с перезаписанной полиморфной функцией. Каждая виртуальная функция имеет свой собственный индекс в виртуальной таблице, вне зависимости от длины наследования.

Если класс-наследник объявляет новую виртуальную функцию, не представленную в базовом классе - виртуальная таблица вырастет на один слот. И адрес нового объявления попадет в этот слот.

---

## 2.1. Небольшой FAQ про виртуальные функции и виртуальные таблицы.

**Вопрос****: Одна виртуальная таблица создается на 1 объект, или на 1 класс?**

- Обычно зависит от компилятора.
- Но по большей части, виртуальная таблица создается на 1 класс а указатель на виртуальную таблицу (`_vptr`) - один на объект.
- Не забываем, что может быть несколько указателей на виртуальные таблицы, завит от наследования.

**Вопрос****: Где и как происходит добавление таблицы/указателя на таблицу, в коде, компилятором?**

- Коду обязательно нужно заполнить/переписать слот виртуальной таблицы во время компиляции. Другими словами, виртуальная таблица генерируется компилятором статически во время компиляции ы конструкторе, перед кодом написанным пользователем.
- Указатель на виртуальную таблицу всегда имеет фиксированное смещение (offset) в памяти. И код, который перезаписывает `_vptr` генерируется во время создания объекта компилятором.
- Именно поэтому нельзя вызывать виртуальные [функции из конструктора](https://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors).

**Вопрос****: Как мы узнает, что указатель** `**protocol**` **выполнит правильную функцию?**

- В целом, мы не знаем реальный тип адреса, который вызывает объект `protocol` при вызове `authenticate()`. Но мы знает, что указатель на виртуальную таблицу имеетl всегда один и тот же offset, который ассоциируется с объектом класса.
- И используя `_vptr` мы можем достучаться до виртуальной таблицы объекта, на которую указывает указатель на `protocol`. И еще раз индекс функции в виртуальной таблице `authenticate()` фиксированный

---

## 3. Как работают чисто виртуальные функции?

Когда какая-то функция объявлена как чисто виртуальная, компилятор автоматически заполняет слот этой чисто виртуальной функции пустой функцией, или так называемым place holder `pure_virtual_called()` . И в рантайме вызывается этот place holder.

Все остальные вызовы виртуальной таблицы ил работы со слотом осуществляются как и в обычной виртуальной функции.

---

## 4. Поддержка виртуальных функций при множественном наследовании.

[[TODO]] Тут в будущем надо будет получше все переписать. После ознакомления со [статьей](https://www.vishalchovatiya.com/memory-layout-of-cpp-object/).

При множественном наследовании все становится немного сложнее.

Рассмотрим так же все на примере:

```C++
struct base1 
{
    int base1_var;

    virtual void base1_func() {}            
    virtual void print()      {}
};

struct base2 
{
    int base2_var;
    
    virtual void base2_func() {}
    virtual void print()      {}
};

struct derived : base1, base2 
{
    int derived_var;

    void print() {}
};
```

В данном случае у нас есть класс `derived` который отнаследован от двух базовых классов. В таком случае в объекте класса `derived` будут сгенерированы два указателя на виртуальные таблицы. Один для `base1`, второй для `base2`.

Выглядеть в памяти это будет так:

```C++
|                        |          
|------------------------| <------ представление в памяти объекта derived
|  base1::base1_var      |          
|------------------------|          |--------->|----------------------|
|  base1::_vptr_base1    |----------|          |   type_info derived  |
|------------------------|                     |----------------------|
|  base2::base2_var      |                     |   base1::base1_func  |
|------------------------|                     |----------------------|
|  base2::_vptr_base2    |----------|          |    derived:::print   |
|------------------------|          |          |----------------------|
|  derived::derived_var  |          |          |------GUARD-AREA------|
|------------------------|          |--------->|----------------------|
|                        |                     |   type_info derived  |
|                        |                     |----------------------|
|                        |                     |   base2::base2_func  |
|                        |                     |----------------------|
                                               |    derived::print    |
                                               |----------------------|
```

Для лучшего понимания, что происходит создадим указатель на `base2` , но который указывает на динамически выделенную память для объекта класса `derived` .

```C++
base2 *pb = new derived;
```

Адрес объекта `derived` должен быть приведен к его `base2` подъобекту (так как базовые классы хранятся внутри наследуемых). Компилятор раскроет строчку выше следующим образом:

```C++
base2* pb = static_cast<base2 *>(new derived());
// Аналогично - " адрес объекта derived + sizeof(base1)"
```

Визуализация памяти, после вышеприведенной операции:

```C++
        |                        |          
        |------------------------| <------ представление в памяти объекта derived
        |  base1::base1_var      |          
        |------------------------|          |--------->|----------------------|
        |  base1::_vptr_base1    |----------|          |   type_info derived  |
pb ---> |------------------------|                     |----------------------|
        |  base2::base2_var      |                     |   base1::base1_func  |
        |------------------------|                     |----------------------|
        |  base2::_vptr_base2    |----------|          |    derived:::print   |
        |------------------------|          |          |----------------------|
        |  derived::derived_var  |          |          |------GUARD_AREA------|
        |------------------------|          |--------->|----------------------|
        |                        |                     |   type_info derived  |
        |                        |                     |----------------------|
        |                        |                     |   base2::base2_func  |
        |                        |                     |----------------------|
                                                       |    derived:::print   |
                                                       |----------------------|
```

Без раскрытия строчки компилятором и неполиморфного использования указателя, следующие вещи не смогли бы отработать:

```C++
pb->base2_var = 5;
```

Или

```C++
pb->print();
```

Раскроется в

```C++
( * pb->_vptr_base2[ 2 ])( pb );
```

---

## 5. Зачем нам нужны виртуальные Классы/Наследование?

Когда мы наследуемся от какого-то базового класса, по сути, мы просто расширяем возможности наследника, вставляю всю функциальность класса-родителя. Другими словами - объект базового класса будет считаться _подобъектом_ наследника.

В результате, это создаст проблему при множественном наследовании, если базовый класс разделяет один и тот же взаимный класс как подобъект в высокоуровневой иерархии.

---

## 5.1. Проблема.

Начнем сразу с примера:

```C++
class Top                { public: int top; };
class Left : public Top  { public: int left; };
class Right : public Top { public: int right; };
class Bottom : public Left, public Right { public: int bottom; };
```

Иерархия классов выше, называется ромбовидной (или “dimond”).

```C++
    Top
   /   \
Left   Right
   \   /
  Bottom
```

Объект класса `Bottom` будет состоять из `Left` (который включает в себя `Top`), и из `Right` (который тоже включает в себя `Top`)

```C++
Bottom *bot = new Bottom;
bot->top = 5; // Возникает вопрос: Мы общаемся к подобъекту Top, который 
              //                   находится в Left или в Right?
```

Пока это был самый простой пример, зачем нам нужно виртуальное наследование.

Вот еще один пример:

```C++
Top *t_ptr1 = new Left;
Top *t_ptr2 = new Right;
```

И первое и второе преобразование будет работать нормально, так как `Left` и `Right` в своем представлении памяти имеет `Top`, как подобъект.

Для лучшего понимания дальнейше показанной проблемы, покажем представление класса `Bottom:`

```C++
|                      |
|----------------------|  <------ Bottom bot;   // объект класса Bottom
|    Left::Top::t      |
|----------------------|
|    Left::l           |
|----------------------|
|    Right::Top::t     |
|----------------------|
|    Right::r          |
|----------------------|
|    Bottom::b         |
|----------------------|
|                      |
```

А теперь вопрос, что случится при следующем приведении:

```C++
Left *left = new Bottom;
```

Данное приведение отработает нормальным образом, потому что представление объекта класса `Bottom` начинается с класса `Left`.

Но что случится, если мы захотим преобразовать `Left` в `Top`.

```C++
Right  *right = new Bottom;
```

Представление памяти объекта `right` будет выглядеть так:

```C++
|                      |
|----------------------|
|    Left::Top::t      |
|----------------------|
|    Left::l           |
|----------------------|  <------ right;
|    Right::Top::t     |
|----------------------|
|    Right::r          |
|----------------------|
|    Bottom::b         |
|----------------------|
|                      |
|                      |
```

И это привидение отработает нормальным образом и мы сможем получить доступ к полям `Bottom` через указатель `right`.

Но если мы захотим приравнять базовый класс к `Bottom`:

```C++
Top* top = new Bottom;
```

Компилятор выдаст ошибку:

```C++
error: `Top` is an ambiguous base of `Bottom`
```

  

---

## 5.2. Решение.

Как раз-таки **Виртуальное Наследование** и призвано решать такие проблемы в ромбовидных классах.

Обозначая наследование в классе **виртуальным**, мы говорим компилятору что хотели бы только один экземпляр класса, который включается дважды, видеть в нашем наследнике.

Выглядеть в коде это будет так:

```C++
class Top                        { public: int top; };
class Left  : virtual public Top { public: int left; };
class Right : virtual public Top { public: int right; };
class Bottom : public Left, public Right { public: int bottom; };
```

```C++
Bottom *bot = new Bottom;
bot->t = 5; // теперь обращение не двусмысленно.
```

---

## 6. Как адресация виртуальных базовых классов работает внутри?

Класс, который включает в себя один или более виртуальных базовых классов (имеет базовый подобъект), как класс `Bottom` , делится на две области:

- Инвариантная область.
- Общая (разделяемая) область.

Данные внутри инвариантной области остается с зафиксированным сдвигом (offset) от начала объекта независимо от последующих производных. Поэтому к объектам включающим в себя инвариантную область можно обращаться напрямую. В нашем случае это `Left` и `Right` и `Bottom` .

  

[[TODO]] Очень непонятно переведено.

  

Кроме того, разделяемая область представляет подобъекты виртуального базового класса, местоположение которых в пределах разделяемой области изменяется в зависимости от порядка вывода и последующего вывода. Таким образом, к участникам в пределах общего региона необходимо обращаться косвенно.

Как следует из названия, инвариантная область помещается в начале компоновки памяти объектов, а общая область - в конце.

Смещение общего региона, обновленное в виртуальной таблице. Необходимый для этого код дополняется компилятором во время построения объекта. Смотрите изображение ниже для справки.

```C++
|                        |          
|------------------------| <---- Bottom bot; // Bottom object           
|    Left::l             |          
|------------------------|           |------------------| 
|    Left::_vptr_Left    |-----|     |  offset of Top   | // offset starts 
|------------------------|     |-----|------------------| // from left subobject
|    Right::r            |           |    ...           | // = 20
|------------------------|           |------------------|  
|    Right::_vptr_Right  |-----|       
|------------------------|     |     |------------------| 
|    Bottom::b           |     |     |  offset of Top   | // offset starts 
|------------------------|     |-----|------------------| // from right subobject                        
|    Top::t              |           |    ...           | // = 12                                  
|------------------------|           |------------------|                                            
|                        |
```

Теперь возвращаясь к нашему вопросу: “Как будет интерпретироваться компилятором это `bot->t`?”

```C++
Bottom *bot = new Bottom;
bot->t = 5;
```

Приведенный выше код, вероятно, будет преобразован в:

```C++
Bottom *bot = new Bottom;
(bot + _vptr_Left[-1])->t = 5; 
// If you haven't got this, then consider the above memory map
```

Итак, как вы можете видеть, адресация виртуального базового класса осуществляется через смещение (базового класса), хранящееся в виртуальной таблице.

  

  

---

## 7. Обработка виртуальных функций в виртуальном классе.

Она ровно такая же, как и в обычном классе. Можно чекнуть пункты выше.

[[TODO]] ДОПИСАТЬ

> [!info] Complications of Using the Virtual Base Class - Vishal Chovatiya  
> In the previous article about How Does Virtual Base Class Works Internally?  
> [https://www.vishalchovatiya.com/complications-of-using-the-virtual-base-class/](https://www.vishalchovatiya.com/complications-of-using-the-virtual-base-class/)  

  

---

## 8. Для чего нужны виртуальные деструкторы?

Вспомним наш первый пример, с подключениями к сети, просто допишем еще деструкторы в классы.

```C++
class protocol_t 
{
    private:
        uint8_t *_type;
    public:
        protocol_t()    { _type = new uint8_t; }
        ~protocol_t()   { cout << "~protocol_t"; delete _type; }

        virtual void authenticate(){};
        virtual void connect(){};
};

class wifi_t : public protocol_t 
{
    private:
        char *_pass;
    public:
        wifi_t()       { _pass = new char[15]; }
        ~wifi_t()      { cout << "~wifi_t"; delete _pass; }

        virtual void authenticate(){};
        virtual void connect(){};
};

class bluetooth_t : public protocol_t 
{
    private:
        char *_pass;
    public:
        bluetooth_t()  { _pass = new char[15]; }
        ~bluetooth_t() { cout << "~bluetooth_t"; delete _pass; }

        virtual void authenticate(){};
        virtual void connect(){};
};

void makeConnection(protocol_t *protocol) 
{
    protocol->authenticate();
    protocol->connect();

    delete protocol;
}    

int main() 
{
    int prot_type = rand() % 2; 

    if (prot_type == WIFI)
    {
        makeConnection(new wifi_t);       // [1]
    }
    else
    {
        makeConnection(new bluetooth_t);  // [1]
    }

    return 0;
}
```

Разберем по пунктам, что происходит в этом примере:

1. Мы создаем объекты класса `wifi_t` и `bluetooth_t` динамически и передаем их в функцию `makeConnection()`.
2. Все объекты типов `wifi_t` , `bluetooth_t` или `protocol_t` использует память выделенную динамически в куче во время разрушения и построения.
3. Если мы просто скомпилируем программу выше, то получим следующую строчку на выходе:
    
    ```C++
    ~protocol_t
    ```
    
4. Но так как мы работаем с типам `wifi_t` и `bluetooth_t` а при вызове `delete` удаляется только подобъект, а все поля объекта так и остаются висеть в памяти - на лицо, явная утечка памяти.
5. Так как в момент рантайма приложения мы не знаем с каким типом объекта работаем, кроме `protocol_t` , мы и не сможем вызвать правильный деструктор для типа-наследника.
    
    Для решения таких проблем и придумали виртуальные деструкторы. Нужно просто вставить ключевое слово `virtual` к деструктуру класса `protocol_t`:
    
    ```C++
    //...
    virtual ~protocol_t() { cout << "~protocol_t"; delete _type; }
    //...
    ```
    
    Теперь вывод будет следующий:
    
    ```C++
    ~bluetooth_t 
    ~protocol_t
    ```
    
    Это значит, что и объект и подобъект из базового класса нормально удалились из динамической памяти.
    
6. **Виртуальный деструктор используется для удаления объекта, на который указывает указатель/ссылка базового класса.**

---

## 9. Как виртуальные деструкторы работают?

Вопрос в том, как же вызывается деструктор класса-наследника?

И тут снова нас спасает указатель на виртуальную таблицу (`_vptr`).

При следующей операции:

```C++
protocol_t *protocol = new wifi_t;
delete protocol;
```

Отображение в памяти будет выглядеть так:

```C++
|                                |          
|--------------------------------| <------ отображение в памяти объекта класса
|  protocol_t::_type             |         wifi_t
|--------------------------------|          
|  protocol_t::_vptr_protocol_t  |----------|
|--------------------------------|          |--------|-------------------------|
|  wifi_t::_pass                 |                   |   type_info wifi_t      |
|--------------------------------|                   |-------------------------|
|                                |                   |   wifi_t::authenticate  |
|                                |                   |-------------------------|
|                                |                   |   wifi_t::connect       |
|                                |                   |-------------------------|
|                                |                   |   wifi_t::~wifi_t       |
|                                |                   |-------------------------|
```

Поэтому выражения `delete protocol;` будет конвертировано в:

```C++
//...
(*protocol->vptr[3])(protocol);
//...
```

Так же стоит обратить внимание во что разворачивает компилятор код деструктора `~wifi_t`

```C++
~wifi_t() { 
    cout<<"~wifi_t"; 
    delete this->_pass;

    // Код добавленный компилятором -------------------------------------------
    // Перемонтируем виртуальную таблицу
    this->vptr = vtable_protocol_t; // vtable_protocol_t - это адрес статичекой 
                                    //                     виртуальной таблицы
    // вызовем деструктор базового класса
    protocol_t::~protocol_t(this); 
    // ------------------------------------------------------------------------
}
```

Поэтому процесс разрушения объекта может занять гораздо больше операций, чем описано у вас в коде. Когда компилятор добавляет в ваш деструктор какой-то код, он делает это и до и после вашего кода.

---

## 10. Разбор кода созданного компилятором при работе с виртуальным деструктором.

Просто так мы не сможем увидеть код, созданный компилятором (если только не произвести дизасембл программы), но можно использовать небольшой лайфхак, что б показать, что код реально создается:

```C++
class base
{
public:
		virtual ~base() = 0;
};

class derived : public base
{
public:
		~derived();
};

int main()
{
		base* pbase = new derived;
		delete pbase;
		return 0;
}
```

Используя чисто виртуальный деструктор, мы получим следующую ошибку компиляции:

```C++
exit status 1
/tmp/main-06bc44.o: In function `derived::~derived()':
main.cpp:(.text._ZN7derivedD2Ev[_ZN7derivedD2Ev]+0x11): undefined reference 
to `base::~base()'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

Ошибка говорит о том, что компилятор пытался добавить код в деструктор базового класса. Но так он не создан - линкер возбудил ошибку.

## Итоги:

1. Стандарт C++ не определяет реализацию, а только определяет поведение динамической диспечеризации (т.е. виртуальной функции).
2. Указатели на виртуальные таблицы (`_vptr`) относятся к объекту.
3. Указатель на виртуальную таблицу(`_vptr`) имеет фиксированный код смещения (offset).
4. Код для переопределения `_vptr` генерируется во время построения объект.
5. Виртуальная таблица относится к классу, а не к объекту.
6. Виртуальная таблица генерируется статически во время компиляции программы.
7. Виртуальные классы нужны для избегания проблем при ромбовидном наследовании.
8. Объект, который имеет виртуально наследуемый подобъект имеет структуру памяти разделенную на два региона
    1. Регион инварианта: тут хранятся не виртуальные классы
    2. Разделяемый регион: тут хранятся виртуальные классы. Данный регион расположен в конце памяти объекта.
9. Адреса элементов данных в виртуальном базовом классе, разрешенные с использованием смещения (offset) (виртуального базового класса), сохраняются в виртуальной таблице.
10. Виртуальный деструктор используется для удаления объекта, на который указывает указатель/ссылка базового класса.
11. Вызов виртуального деструктора выполняется с использованием динамической диспетчеризации.
12. Компилятор дополняет код деструктора производного класса, вставляя вызов деструктора базового класса.
13. Тип объекта во время выполнения - это тип класса, который создается/уничтожается в это время, даже если исходный объект, который создается/ уничтожается, имеет производный тип.