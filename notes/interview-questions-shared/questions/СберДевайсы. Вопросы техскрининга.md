- Кросс-компиляция
    
    Это компиляция исходного кода на одной платформе в исполняемый файл для другой платформы. Например, Visual Studio на Windows позволяет компилировать под Linux.
    
- move-семантика и r-value
    
    Используется для ускорения кода и уменьшения потребления памяти (снижение накладных расходов за счет отсутствия операции копирования). Полезно, когда в функцию передаются временные объекты, либо объекты, которые стали ненужными в вызывающей функции (владение передается). Классический пример - move-конструктор для std::vector.
    
    Примечание: если сделать вызов `SomeFn(std::move(obj))` и потом обратиться к `obj` в вызывающей функции, то в общем случае программа может упасть (UB).
    
    Примечание: если есть умный указатель `std::unique_ptr u_ptr` сделать вызов `SomeFn(std::move(u_ptr))`, то `u_ptr` обнулится (явная передача владения указателем).
    
    [https://ru.stackoverflow.com/questions/1044875/c-stdmove-pod-типы-и-неопределенное-поведение](https://ru.stackoverflow.com/questions/1044875/c-stdmove-pod-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8-%D0%BD%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)
    
    Пример неспецифицированного состояния после std::move - std::string
    
- Работа с многопоточностью в C++
    
    - Использовать примитивов синхронизации (мьютексы, семафоры, условные переменные)
    - Атомики/атомарные переменные
    - Минимизировать использование разделяемой памяти, либо явно сегментировать, если возможно гарантировать, что потоки, работающие с этими сегментами, не пересекаются
    - Максимизировать использование разделяемых операций
    - Использовать библиотечные функции (std), которые имеют кастомизируемые политики выполнения (sequenced/parallel)
    - Использовать RAII (аналогично умным указателям) для управления мьютексами (std::lock_guard) и тд, чтобы избежать ситуации, когда мьютекс оказался заблокированным (например, при early function return - раннем возврате из функции).
    
      
    
- Виртуальный метод
    
    Метод/функция класса, который может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения (то есть в рантайме). В C++ это реализуется через таблицу виртуальных методов класса (_virtual function table, virtual call table, dispatch table, vtable, or vftable_). Расположение в памяти этой таблицы как правило зависит от реализации, но, например, в MSVC она находится в начале памяти, выделенной под объект класса. С помощью reinterpret_cast’a можно делать всякие грязные трюки с ней.  
      
- Команда fork()
    
    Создает почти полную копию процесса, делает его потомком по отношению к вызываемому.
    
    Не наследуются:
    
    - идентификаторы процесса (PID, PPID);
    - количество израсходованное времени ЦП (оно обнуляется);
    - сигналы процесса-родителя, требующие ответа;
    - блокированные файлы (record locking).
    
    Наследуются:
    
    - таблица файлов, в которой находятся состояния флагов дескрипторов файла, указывающие, читается ли файл или пишется. Кроме того, в таблице файлов содержится текущая позиция указателя записи-чтения;
    - рабочий и корневой каталоги;
    - номер пользователя и номер группы;
    - ограничения по ресурсам;
    - сведения о среде выполнения;
- WatchDog
    
    Сторожевой таймер, реже контрольный таймер (_watchdog timer_) — аппаратно реализованная (программно тоже может) схема контроля над зависанием системы, либо отдельно взятого приложения.
    
- Что такое smart pointers в C++? Какие типы smart pointers вы использовали?
    
    Smart pointers (умные указатели) - это классы, которые обеспечивают автоматическое управление памятью (используется идиома RAII). В C++ есть несколько типов smart pointers, таких как std::shared_ptr, std::unique_ptr и std::weak_ptr.
    
- В чём разница между потоком и процессом?
    
    У потоков общая память, а у каждого процесса своя. Поток может получить доступ к переменной другого потока, а процессу для этого нужно использовать специальные механизмы межпроцессного взаимодействия, типа `boost::interprocess::message_queue`. Переключение контекста процесса происходит гораздо медленнее, чем переключение контекста потока и т.д.
    
- Использовали ли мультипоточность на практике?
    
    расскажи ))
    
- Использовали ли std::condition_variable на практике?
    
    расскажи ))
    
- Какие системы сборки использовали?
    
    расскажи ))
    
- Отличие между адресным пространством User Space и Kernel Space  
    (пространство пользователя и пространство ядра)?  
    
- А как бы вы реализовали свой UDP based протокол с подтверждением  
    доставки?  
    
    Оказывается, все шутят, что реализовали бы просто заново TCP. Я не был исключением. Имхо просто дропнуть легаси от TCP и использовать те же самые принципы, либо глянуть в сторону гугловского QUIC